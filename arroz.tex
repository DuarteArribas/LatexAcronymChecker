%====== APPLICATION LAYER ======
%==== APPLICATION LAYER CONTENT ====
%== Content ==
\section{Application Layer}
\label{section:applicationLayer}
The \textit{application layer} is the topmost layer of both the \ac{OSI} and TCP/IP models and also the topmost layer of the hybrid model presented in this book.
% TCP
It is the only layer concerned with providing real work for users, instead of information transportation (which happen at the other layers); the shared protocols and interfaces used by hosts abstract their communication during a network communication.

The user applications (programs) run on different end systems and not on networking components.

\subsection{Application Layer Architectures}
\label{subsection:applicationLayerArchitecture}
Each application developed in the application layer needs an underlying application architecture describing the way the application will be designed and built. It is designed by the application developer and dictates how the application is structured over the various end systems.

\subsubsection{Client-Server Architecture}
\label{subsubsection:clientServerArchitecture}
A \textit{client-server} architecture is an application layer architecture where clients communicate with the server, but never \textbf{directly} with themselves.

The \textit{server} is an \textit{always-on host}, containing some fixed/permanent \acs{IP} address\footnote{More on \acs{IP} addresses on section \ref{section:networkLayer}}, which services intermittently connected \textit{clients}, which can communicate with the server by sending requests. 

Figure \ref{fig:clientServerArchitecture} shows how this architecture works and figure \ref{fig:clientServer} represents a diagram of a client-server architecture in a set of different networks.

\begin{figure}[!b]
  \centering
  \begin{sequencediagram}
    \newthread{client}{Client}
    \newthread{server}{Server}
    \begin{call}{server}{Wait for client request}{server}{}\end{call}
    \mess[1]{client}{Request}{server}
    \begin{call}{server}{Process client request}{server}{}\end{call}
    \mess[1]{server}{Response}{client}
  \end{sequencediagram}
  \caption{Client-Server architecture}
  \label{fig:clientServerArchitecture}
\end{figure}

\begin{figure}[!b]
\centering
\includegraphics[width=2.5in]{images/clientServer.png}
\caption{Client-Server architecture inside a network.}
\label{fig:clientServer}
\end{figure}

Some applications may require multiple servers to keep up with the number of requests of the clients; for that reason, many applications converge a larger number of servers into a unique virtual server, housed in data centers (more information in volume 3.).

\subsubsection{Peer to Peer}
\label{subsubsection:peerToPeer}
A \textit{\ac{P2P}} architecture is an application layer architecture where clients communicate \textbf{directly} with each other, hence there is \textbf{not} a need for a dedicated always-on host server to communicate with and service the clients; the clients are called \textit{peers}.

Peers are intermittently connected and communicate between themselves arbitrarily.

\Ac{P2P} architectures are \textit{self-scalable} in the sense that as more requests happen, the system can scale by itself.

Figure \ref{fig:p2p} represents a diagram of a \ac{P2P} architecture in a set of different networks.

\begin{figure}[!b]
  \centering
  \includegraphics[width=2.5in]{images/p2p.png}
  \caption{\ac{P2P} architecture inside a network.}
  \label{fig:p2p}
\end{figure}

\subsubsection{Hybrid}
\label{subsubsection:hybrid}
A \textit{hybrid} architecture is an application layer architecture, where there is a mix of client-server architectures and \Ac{P2P} architectures.

\subsection{Process Communication}
\label{subsection:processCommunication}
Programs running on computers are identified in \acp{OS} by \textit{processes}. Processes on the same computer communicate with each other through \textit{interprocess communication} (controlled by the \ac{OS}); however, processes on the Internet must exchange \textit{messages} across computer networks.

Processes that send messages across a computer network are called \textit{servers} and processes that receive those messages across a computer network are called \textit{clients} (not to be confused with the servers and clients in the client-server model of section \ref{subsubsection:clientServerArchitecture}, as, indeed, in \ac{P2P} architectures, both peers can be both the server and the client, depending on who is sending and receiving the message).

Because a server can be running several network applications, hosts need two things to be able to communicate:

\begin{itemize}
  \item The \acs{IP} address of the host to send data;
  \item The port number of the host to send data.
\end{itemize}.

The port number identifies the interface which connects an application process to the computer network, a \textit{socket}, which is an \ac{API} between the application and the rest of the network, as shown in figure \ref{fig:sockets}.

\begin{figure*}[!t]
\centering
\includegraphics[width=0.7\textwidth]{images/socket.png}
\caption{Communication between a server and a client through the Internet using sockets}
\label{fig:sockets}
\end{figure*}

When designing network applications, the application developer has little control over the layers below the application layer and sockets are used to abstract all the communications in some function calls, i.e., the application sends the message into the socket (interface), which will, then, send it to the remaining layers. Besides choosing the transport layer protocol to be used and some header parameters, the developer does not have much saying in the rest of the communication.

\subsubsection{Socket Programming}
\label{subsubsection:socketProgramming}
There are two ways to design network applications:

\begin{itemize}
  \item \textit{Open}: its implementation is specified in a protocol standard; a developer (or team) that creates a server application conforming to a protocol standard will be able to interoperate with a client made by another developer (or team) that also followed that standard. E.G.: Google Chrome client and Apache web server;
  \item \textit{Closed}: its implementation is not standardly defined in any protocol and the developer chooses what implementations should be made client- and server-side. It is very hard to interoperate with another developer (or team), unless they also know the actual implementation.
\end{itemize}

Open network applications \textbf{must} use the port numbers defined in the protocol standard and \textbf{closed} network applications \textbf{should} avoid using standard port numbers defined in protocol standards.

There are two types of sockets:

\begin{itemize}
  \item \textit{\acs{TCP}}: sockets which interface with the \acs{TCP} transport layer protocol;
  \item \textit{\acs{UDP}}: sockets which interface with the \acs{UDP} transport layer protocol.
\end{itemize}

Section \ref{section:transportLayer} explains both protocols. Refer to any programming language volume an implementation of \acs{TCP} and \acs{UDP} sockets in that programming language.

\subsection{Domain Name System}
\label{subsection:dns}
\acs{IP} addresses are used to name the location of end-systems (more on this in section \ref{section:networkLayer}), however they are hard to remember, as they are arbitrary sequences of numbers. Because of this, it was decided to name addresses according to some standard.

The \ac{DNS} is a hierarchical, domain-based naming scheme, distributed database that implements a mapping between \acs{IP} addresses 



\subsection{World Wide Web}
\label{subsection:www}

The \ac{WWW} (W3, web) is an abstract web application for accessing linked content over the Internet. It was created by Tim Berners-Lee in 1990; soon after, he created the \ac{W3C}, a group of developers, researchers, etc., to standardize and develop the web further.

Many people mistake it for the "Internet", because it is the most known and successful web application, because of its ease of use and enormous wealth of information.

\subsection{Architectural Overview of the World Wide Web}
\label{subsection:architecturalOverviewOfTheWWW}

The \acf{WWW} consists of publicly accessible \textit{websites}, which are a collection of web pages linked to each other and related content (such as multimedia content) published on at least one \textit{web server}.

A \textit{web page} is a document that can be displayed by a \textit{web client}; web pages inside a website point to each other through \textit{hyperlinks}, which redirect the user to another page; the text displayed by an hyperlink is called \textit{hypertext}.

\subsection{Web Clients - Browsers}
\label{subsection:webClientsBrowsers}

The most common type of web client is called a \textit{browser}. Examples of popular web browsers are \textit{Microsoft Internet Explorer}\footnote{Available at https://www.microsoft.com/en-us/download/internet-explorer.aspx.}, \textit{Microsoft Edge}\footnote{Available at https://www.microsoft.com/en-us/edge.}, \textit{Chromium}\footnote{Available at https://www.chromium.org/chromium-projects/.}, \textit{Google Chrome}\footnote{Available at https://www.google.com/chrome/.}, \textit{Mozilla Firefox}\footnote{Available https://www.mozilla.org/en-US/firefox/new/.}, \textit{Opera}\footnote{Available at https://www.opera.com/.}, \textit{Apple Safari}\footnote{Available at https://www.apple.com/safari/.}, \textit{Vivaldi}\footnote{Available at https://vivaldi.com/.}, \textit{Brave}\footnote{Available at https://brave.com/.}, \textit{Tor}\footnote{Available at https://www.torproject.org/.}. 

The browser fetches a page, interprets the content and displays it, properly formatted, on the screen. A broswer is able to identify what page to fetch, where it is located, 